(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{476:function(e,t,n){"use strict";n.r(t);var r=n(56),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"h-264视频解码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#h-264视频解码"}},[e._v("#")]),e._v(" H.264视频解码")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 获取解码器\nm_codec=avcodec_find_decoder(AV_CODEC_ID_H264);\n\n//初始化解析器\nif(!m_parser)\n    m_parser = av_parser_init(AV_CODEC_ID_H264);\n\n// 分配codec上下文67\nif(!m_decoder)\n    m_decoder=avcodec_alloc_context3(m_codec);\n\n// 将解码器和解码器上下文关联\nif (avcodec_open2(m_decoder, m_codec, NULL) < 0) {\n    fprintf(stderr, "Could not open codec\\n");\n    return false;\n}\n\n// 创建AVPacket\nif(!m_avpkt)\n    m_avpkt=av_packet_alloc();\n\n// 创建AVFrame\nif(!m_frame)\n    m_frame = av_frame_alloc();\n')])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('int H264Decoder::phaseData(char *data, int length)\n{\n    if (!data){\n        return 1;\n    }\n    //从数据流中解码出图像\n    while(length){\n        //从数据流中获取AVPaket数据\n        int parsedLength = av_parser_parse2(m_parser,m_decoder,&m_avpkt->data,&m_avpkt->size,(const uint8_t*)data,length,AV_NOPTS_VALUE,AV_NOPTS_VALUE,AV_NOPTS_VALUE);\n        data += parsedLength;\n        length -= parsedLength;\n        //如果已获取一帧数据\n        if (m_avpkt->size){\n            //测试\n            d_readSize = 0;\n            //测试\n            phaseFrame();\n        }\n    }\n    return 0;\n}\n\nint H264Decoder::phaseFrame()\n{\n    int ret;\n    AVFrame *tmp_frame = nullptr;//临时空间\n    m_needInit = true;//解码器接收数据后置为true\n\n    // 给解码器传入包含原始压缩数据的AVPacket对象\n    ret=avcodec_send_packet(m_decoder,m_avpkt);\n    if (ret<0){\n        fprintf(stderr,"Error during decoding ret:%d\\n",ret);\n         releaseDecoder();\n         initFrame(m_cuda);\n        return ret;\n    }\n    m_needInit = true;//解码器接收数据后置为true\n\n    while(ret>=0){\n        // 从解码器返回已解码的输出数据\n        ret=avcodec_receive_frame(m_decoder,m_frame);\n        if(ret==AVERROR(EAGAIN)||ret==AVERROR(AVERROR_EOF))\n            return 0;\n        else if(ret<0){\n            fprintf(stderr,"Error while decoding ret:%d\\n",ret);\n            return ret;\n        }\n        if (m_out_buffer == nullptr) {\n            m_BGRsize = avpicture_get_size(AV_PIX_FMT_RGB24, m_decoder->width,m_decoder->height);\n//            m_out_buffer = (uint8_t *)av_malloc(m_BGRsize);\n            m_out_buffer = new uint8_t[m_BGRsize];\n            //初始化一个AVPicture结构体，并将它与一段内存关联起来，这段内存用于存储图像数据\n            avpicture_fill((AVPicture *)m_pFrameBGR, m_out_buffer, AV_PIX_FMT_RGB24,\n                           m_decoder->width, m_decoder->height);\n\n            if(m_cuda==true)\n                m_img_convert_ctx = sws_getContext(m_decoder->width, m_decoder->height,(enum AVPixelFormat)23 ,\n                                                   m_decoder->width, m_decoder->height, AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);\n            else\n                m_img_convert_ctx = sws_getContext(m_decoder->width, m_decoder->height,(enum AVPixelFormat)0 ,\n                                               m_decoder->width, m_decoder->height, AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);\n            m_lastWidth = m_decoder->width;\n            m_lastHeight = m_decoder->height;\n        }\n        if(m_lastWidth != m_decoder->width || m_lastWidth != m_frame->width || m_lastHeight != m_decoder->height ||m_lastHeight != m_frame->height){\n            releaseDecoder();\n            initFrame(m_cuda);\n            return 0;\n        }\n        if (ret>=0) {\n            m_frame_count++;\n            m_matReady = true;\n            if (m_frame->format == hw_pix_fmt) {\n                /* retrieve data from GPU to CPU */\n                //av_hwframe_transfer_data()将数据复制到硬件或从硬件复制数据。\n                if (av_hwframe_transfer_data(sw_frame, m_frame, 0) < 0) {\n                    fprintf(stderr, "Error transferring the data to system memory\\n");\n                }\n                tmp_frame = sw_frame;\n            }\n            else\n                tmp_frame = m_frame;\n            sws_scale(m_img_convert_ctx, (const uint8_t *const *)tmp_frame->data,\n                      tmp_frame->linesize, 0, tmp_frame->height, m_pFrameBGR->data, m_pFrameBGR->linesize);\n            // sws_scale(m_img_convert_ctx, (const uint8_t *const *)tmp_frame->data,\n            //           tmp_frame->linesize, 0, m_decoder->height, m_pFrameBGR->data, m_pFrameBGR->linesize);\n            if(m_getImgFunc!=nullptr){\n                // 将解码后的图像输出\n                m_getImgFunc(m_out_buffer, tmp_frame->width, tmp_frame->height,3);\n                // m_getImgFunc(m_out_buffer, m_decoder->width, m_decoder->height,3);\n            }\n        }\n        else {\n            m_matReady = false;\n        }\n    }\n    return ret;\n}\n')])])]),n("p",[n("img",{attrs:{src:"C:%5CUsers%5Cjyb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240123132954262.png",alt:"image-20240123132954262"}})]),e._v(" "),n("ol",[n("li",[e._v("av_parser_parse2从数据流中获取AVPaket数据")]),e._v(" "),n("li",[e._v("avcodec_send_packet给解码器传入包含原始压缩数据的AVPacket对象")]),e._v(" "),n("li",[e._v("avcodec_receive_frame从解码器返回已解码的输出数据，存储在AVFrame中")]),e._v(" "),n("li",[e._v("AVPacket负责存储压缩的音视频数据")]),e._v(" "),n("li",[e._v("AVFrame用于存储解码后的音视频数据")])])])}),[],!1,null,null,null);t.default=_.exports}}]);